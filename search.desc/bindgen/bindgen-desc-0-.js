searchState.loadedDescShard("bindgen", 0, "Generate Rust bindings for C and C++ libraries.\nThe “aapcs” ABI.\nA valid rust ABI.\nEnum for how aliases should be translated.\nError type for rust-bindgen.\nWrap members in a type generated by bindgen.\nGenerated Rust bindings.\nConfigure and generate Rust bindings for a C/C++ header.\nThe default C ABI.\nWhether to generate constructors\nThe “C-unwind” ABI.\nA ParseCallbacks implementation that will act on file …\nClang diagnosed an error.\nExtracted Clang version data\nA type used to indicate which kind of items we have to …\nThe code for this enum will use consts\nDefault prefix for the anon fields.\nWhether to generate destructors.\nA helper type that represents different enum variations.\nWhether to generate functions.\nThe “fastcall” ABI.\nThe header was a folder.\nPermissions to read the header is insufficient.\nLatest stable release of Rust\nWhether to generate methods.\nEnum for the default type of macro constants.\nWrap members in <code>::core::mem::ManuallyDrop</code>.\nThe code for this enum will use a module containing consts\nThe code for this enum will use a newtype\nCreate a new type by wrapping the old type in a struct and …\nSame as NewStruct but also impl Deref to be able to use …\nNightly rust\nEnum for how non-Copy unions should be translated.\nThe header does not exist.\nStrings of allowed <code>RustTarget</code> values\nThe code for this enum will use a Rust enum. Note that …\nRepresents the version of the Rust language to target.\nUse i32 or i64\nRust stable 1.0\nRust stable 1.17\nRust stable 1.19\nRust stable 1.20\nRust stable 1.21\nRust stable 1.25\nRust stable 1.26\nRust stable 1.27\nRust stable 1.28\nRust stable 1.30\nRust stable 1.33\nRust stable 1.36\nRust stable 1.40\nRust stable 1.47\nRust stable 1.64\nThe “stdcall” ABI.\nWhether to generate types.\nThe “thiscall” ABI.\nConvert to regular Rust alias\nUse u32 or u64\nWhether to generate constants.\nThe “vectorcall” ABI.\nThe “win64” ABI.\nReturns the set containing all flags.\nAllowlist the given file so that its contents appear in …\nAllowlist the given function so that it (and all types …\nWhether to allowlist recursively or not. Defaults to true.\nAllowlist the given type so that it (and all types that it …\nAllowlist the given variable so that it (and all types …\nUse the given prefix for the anon fields.\nSet whether <code>arr[size]</code> should be treated as <code>*mut T</code> or …\nConvert a <code>MacroTypeVariation</code> to its str representation.\nConvert an <code>AliasVariation</code> to its str representation.\nConvert an <code>NonCopyUnionStyle</code> to its str representation.\nMark the given union (or set of union, if using a pattern) …\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nMark the given enum (or set of enums, if using a pattern) …\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nGenerate <code>#[macro_use] extern crate block;</code> instead of …\nHide any contents of the given file from the generated …\nHide the given function from the generated bindings. …\nHide the given item from the generated bindings, …\nHide the given type from the generated bindings. Regular …\nConstruct a new <code>Builder</code>.\nGenerate types with C style naming.\nA public API for more fine-grained customization of …\nAdd an argument to be passed straight through to clang.\nAdd arguments to be passed straight through to clang.\nGet the major and the minor semver numbers of Clang’s …\nGenerates the command line flags use for creating <code>Builder</code>.\nReturns the complement of this set of flags.\nTreat inline namespaces conservatively.\nMark the given enum (or set of enums, if using a pattern) …\nMark the given enum (or set of enums, if using a pattern) …\nReturns true if constructors should be generated.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nUse the given prefix for the raw types instead of …\nGives the latest stable Rust version\nSet the default style of code to generate for typedefs\nSet the default style of code to generate for enums\nSet the default type for macro constants\nSet the default style of code to generate for unions with …\nAdd a depfile output which will be written alongside the …\nSet whether <code>Copy</code> should be derived by default.\nSet whether <code>Debug</code> should be derived by default.\nSet whether <code>Default</code> should be derived by default.\nSet whether <code>Eq</code> should be derived by default.\nSet whether <code>Hash</code> should be derived by default.\nSet whether <code>Ord</code> should be derived by default. We can’t …\nSet whether <code>PartialEq</code> should be derived by default.\nSet whether <code>PartialOrd</code> should be derived by default. If we …\nReturns true if destructors should be generated.\nWhether to detect include paths using clang_sys.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nDisable insertion of bindgen’s version identifier into …\nDisable name auto-namespacing.\nDisable nested struct naming.\nDisable support for native Rust unions, if supported.\nPreprocess and dump the input header files to disk.\nSpecify the dynamic library name if we are generating …\nRequire successful linkage for all routines in a shared …\nEmit bindings for builtin definitions (for example …\nEmit Clang AST.\nEmit IR.\nSet the output graphviz file.\nEmit all the warning messages raised while generating the …\nReturns an empty set of flags.\nEnable C++ namespaces.\nEnable detecting must_use attributes on C functions.\nIf true, always emit explicit padding fields.\nSimple macro that forwards to assert! when using …\nSimple macro that forwards to assert_eq! when using …\nWhether to try to fit macro constants to types smaller …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nCreate a <code>EnumVariation</code> from a string.\nCreate a <code>MacroTypeVariation</code> from a string.\nCreate an <code>AliasVariation</code> from a string.\nCreate a <code>RustTarget</code> from a string.\nfull version string\nReturns true if functions should be generated.\nGenerate the Rust bindings using the options built up thus …\nGenerate proper block signatures instead of void pointers.\nWhether the generated bindings should contain …\nWhether inline functions should be generated or not.\nAdd an input C/C++ header to generate bindings for.\nAdd <code>contents</code> as an input C/C++ header named <code>name</code>.\nIgnore functions.\nIgnore methods.\nSet whether <code>Debug</code> should be implemented, if it can not be …\nSet whether <code>PartialEq</code> should be implemented, if it can not …\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nSet whether layout tests should be generated.\nMark the given union (or set of union, if using a pattern) …\nIf true, merges extern blocks.\nReturns true if methds should be generated.\nAdd a given line to the beginning of module <code>mod</code>.\nAdd a given set of lines to the beginning of module <code>mod</code>.\nAdd <code>#[must_use]</code> for the given type. Regular expressions …\nMark the given typedef alias (or set of aliases, if using …\nMark the given typedef alias (or set of aliases, if using …\nMark the given enum (or set of enums, if using a pattern) …\nMark the given enum (or set of enums, if using a pattern) …\nAvoid converting floats to <code>f32</code>/<code>f64</code> by default.\nDon’t derive <code>Copy</code> for a given type. Regular expressions …\nDon’t derive <code>Debug</code> for a given type. Regular expressions …\nDon’t derive/impl <code>Default</code> for a given type. Regular …\nDon’t derive <code>Hash</code> for a given type. Regular expressions …\nDon’t derive <code>PartialEq</code> for a given type. Regular …\nReturns the complement of this set of flags.\nGenerate <code>#[macro_use] extern crate objc;</code> instead of …\nTreat the given type as opaque in the generated bindings. …\nOverride the ABI of a given function. Regular expressions …\nAllows configuring types in different situations, see the …\nMajor and minor semver, if parsing was successful\nPrepend the enum name to constant or newtype variants.\nAdd a string to prepend to the generated bindings. The …\nSet whether we should record matched items in our regex …\nRemoves the specified flags in-place.\nGenerate bindings as <code>pub</code> only if the bound item is …\nSpecify the rust target\nSet whether rustfmt should format the generated bindings.\nSet the absolute path to the rustfmt configuration file, …\nMark the given enum (or set of enums, if using a pattern) …\nMark the given enum (or set of enums, if using a pattern) …\nInserts or removes the specified flags depending on the …\nSet whether <code>size_t</code> should be translated to <code>usize</code> …\nIf true, enables the sorting of the output in a predefined …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nSet whether or not to time bindgen phases, and print …\nToggles the specified flags in-place.\nAlways translate enum integer types to native Rust integer …\nWhether to use the clang-provided name mangling. This is …\nMark the given typedef alias (or set of aliases, if using …\nReturns true if types should be generated.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nUse core instead of libstd in the generated bindings.\nReturns true if constants should be generated.\nIf true, enables experimental support to generate vtable …\nReturn all the warning messages raised while generating …\nSet the wasm import module name\nChoose what to generate using a <code>CodegenConfig</code>.\nSets an explicit path to rustfmt, to be used when rustfmt …\nIf true, wraps unsafe operations in unsafe blocks.\nWrite these bindings as source text to the given <code>Write</code>able.\nWrite these bindings as source text to a file.\nIndicates whether the newtype will have bitwise operators\nIndicates whether the variants will be represented as …\nIndicates whether the generated struct should be …\nA <code>bool</code>.\nA boolean constant.\nA platform-dependent <code>char</code> type, with the signedness …\nThis variant will be constified, that is, forced to …\nThe <code>Copy</code> trait.\nA custom integer type, used to allow custom macro types …\nThe <code>Debug</code> trait.\nThe <code>Default</code> trait.\nThe default behavior bindgen would have otherwise.\nRelevant information about a type to which new derive …\nWhich trait to consider when doing the <code>CannotDerive</code> …\nAn enum representing custom handling that can be given to …\nA constant value assigned to an enumeration variant.\nThe <code>Hash</code> trait.\nThis variant will be hidden entirely from the resulting …\nAn <code>int128_t</code>\nA 16-bit signed integer.\nA 32-bit signed integer.\nA 64-bit signed integer.\nA 8-bit signed integer.\nIgnore the macro, generating no code for it, or anything …\nWhether it is possible or not to automatically derive …\nAn <code>int</code>.\nWhich integral type are we dealing with?\nA <code>long</code>.\nA <code>long long</code>.\nAn enum to allow ignoring parsing of macros.\nThe only thing that stops us from automatically deriving …\nThis variant will be a module containing constants.\nNo, we cannot.\nA trait to allow configuring different kinds of types in …\nThe <code>PartialEq</code> and <code>PartialOrd</code> traits.\nA <code>signed char</code>.\nA <code>short</code>.\nA signed constant.\nA <code>uint128_t</code>.\nEither a <code>char16_t</code> or a <code>wchar_t</code>.\nA 32-bit unsigned integer.\nA 64-bit unsigned integer.\nA 8-bit unsigned integer.\nAn <code>unsigned char</code>.\nAn <code>unsigned int</code>.\nAn <code>unsigned long</code>.\nAn <code>unsigned long long</code>.\nAn <code>unsigned short</code>.\nAn unsigned constant.\nAn <code>wchar_t</code>.\nYes, we can derive automatically.\nProvide a list of custom derive attributes.\nThis will be called to determine whether a particular …\nThis function should return whether, given an enum variant …\nAllows to rename an enum variant, replacing …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis will be run on every function-like macro. The …\nThis function will run for every function. The returned …\nThis will be called on every file inclusion, with the full …\nThe integer kind an integer macro should have, given a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this integral type signed?\nAllows to rename an item, replacing <code>_original_item_name</code>.\nTake the least upper bound of <code>self</code> and <code>rhs</code>.\nIf this type has a known size, return it (in bytes). This …\nThe name of the type.\nProcess a source code comment.\nWhether this type’s signedness matches the value.\nThis will be run on every string macro. The callback …\nThis function will be run on every macro that is …\nWhether the char is signed for the target platform.\nWhether the type is signed or not.\nThe name of the type, which would be used without …")